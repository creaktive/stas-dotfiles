#!/usr/bin/perl
use 5.008;
use open q(:locale);
use strict;
use utf8;
use warnings qw(all);

use File::Spec::Functions;
use Getopt::Long;
use List::Util qw(max sum);
use Pod::Usage;
use Storable qw(lock_retrieve lock_store);
use Term::ANSIColor;

## no critic (ProhibitBacktickOperators ProhibitComplexRegexes ProhibitInteractiveTest)
our $VERSION = 0.1;

my @ticks = qw[▁ ▂ ▃ ▄ ▅ ▆ ▇ █];

my $tmux = not -t \*STDOUT;
GetOptions(
    q(help)     => \my $help,
    q(battery!) => \my $show_battery,
    q(bright!)  => \my $bright,
    q(max=i)    => \my $threshold,
    q(tmux!)    => \$tmux,
    q(width=i)  => \my $width,
) or pod2usage(q(-verbose) => 1);
pod2usage(q(-verbose) => 2) if $help;
$show_battery = 1 unless defined $show_battery;
$threshold = 1 unless defined $threshold;
$width = 38 unless defined $width;
$bright = 0 unless defined $bright;

my $history = catfile($ENV{HOME}, q(.rainbarf.dat));

my $chart = eval { lock_retrieve $history };
$chart = [ (0) x $width ] unless defined $chart;

my @load = load();

push @$chart => $load[0];
splice @$chart => 0, @$chart - $width if @$chart > $width;
lock_store $chart => $history;

unshift @$chart => (0) x ($width - @$chart);

my %colors = qw(
    f   green
    w   red
    c   red
    a   yellow
    i   blue
);

my %memory = memory();

my $scale = @$chart / sum values %memory;
my $norm = $#ticks / max @$chart => $threshold;
my $c = 0;
for my $type (sort keys %memory) {
    print my_color(($colors{$type}) x 2);
    for (1 .. max(1 => sprintf q(%.0f) => $scale * $memory{$type})) {
        last if $c++ >= $width;
        print $ticks[$norm * shift @$chart];
    }
}
print $ticks[$norm * $load[2]] if $c < $width;

battery() if $show_battery;

print color(q(reset)) => qq(\n) unless $tmux;

sub my_color {
    my ($fg, $bg) = @_;
    my $out;

    if ($tmux) {
        $fg .= q(,bright) if $bright;
        $out = qq(#[fg=$fg]);
        $out .= qq(#[bg=$bg]) if defined $bg;
    } else {
        $fg = qq(bright_$fg) if $bright;
        $out = color defined($bg) ? qq($fg on_$bg) : $fg;
    }

    return $out;
}

sub load {
    my @l;
    if (open my $loadavg, q{<}, q{/proc/loadavg}) {
        @l = (split /\s+/x, <$loadavg>)[0 .. 2];
        close $loadavg;
    } elsif (-x q{/usr/bin/uptime}) {
        @l = (split /\s+/x, qx{/usr/bin/uptime})[-3 .. -1];
    }
    return @l;
}

sub memory {
    my %m;
    if (-x q{/usr/bin/vm_stat}) {
        %m = map {
            /\bPages\s+(free|active|inactive|speculative|wired\s+down):\s*(\d+)/ix
                ? (chr ord $1 => $2 << 2)
                : ();
        } qx{/usr/bin/vm_stat};
        $m{f} += delete $m{s};
    } elsif (open my $meminfo, q{<}, q{/proc/meminfo}) {
        %m = map {
            /\b(?:Mem)?(Free|Cached|SwapCached|Active|Inactive):\s*(\d+)/ix
                ? (lc chr ord $1 => $2)
                : ();
        } <$meminfo>;
        $m{c} -= delete $m{s};
        close $meminfo;
    }
    return %m;
}

sub battery {
    my ($battery, $charging);
    if (-x q{/usr/sbin/ioreg}) {
        my @battery = map {
            /"(?:(?:Max|Current)Capacity|ExternalConnected)"\s*=\s*(\d+|Yes|No)/ix
                ? $1
                : ()
        } qx{/usr/sbin/ioreg -n AppleSmartBattery -r};
        $charging = ($battery[2] =~ /^y/ix);
        $battery = $battery[1] / $battery[0];
    } elsif (
        -x q{/usr/bin/acpi}
        and qx{/usr/bin/acpi} =~ /^Battery\s+0:\s+(\w+),\s+(\d+)%/ix
    ) {
        $charging = $1 ne q{Discharging};
        $battery = $2 / 100;
    }

    if (defined $battery) {
        print my_color(($charging ? q(green) : q(red)), q(black)) => q(|);
        if ($battery < 0.333) {
            print my_color(q(red));
        } elsif ($battery < 0.666) {
            print my_color(q(yellow));
        } else {
            print my_color(q(green));
        }
        print $ticks[$#ticks * $battery];
    }

    return;
}

__DATA__
=pod

=head1 NAME

rainbarf - CPU/RAM stats for TUI

=head1 VERSION

version 0.1

=head1 SYNOPSIS

 rainbarf --tmux --width 40 --no-battery

=head1 DESCRIPTION

Fancy resource usage charts to put into the L<tmux|http://tmux.sourceforge.net/> status line.
The load history chart is tinted with the following colors to reflect the system memory allocation:

=over 4

=item * B<green>: free memory;

=item * B<red>: wired memory on I<Mac OS X>, cached memory on I<Linux>;

=item * B<yellow>: active memory;

=item * B<blue>: inactive memory.

=back

If available, battery charge is displayed on the right.

Just go to L<https://github.com/creaktive/rainbarf> to see some screenshots.

=head1 USAGE

Put F<rainbarf> into your C<$PATH>.
Add the following line to your F<~/.tmux.conf> file:

 set -g status-right '#(rainbarf)'

Or, under I<GNOME Terminal>:

 set -g status-right '#(rainbarf --bright)'

Reload the tmux config by running C<tmux source-file ~/.tmux.conf>.

=head1 OPTIONS

=over 4

=item --help

This.

=item --[no]battery

Display the battery charge indicator.

=item --[no]bright

Tricky one. Disabled by default. See L</CAVEAT>.

=item --max

Maximum load you expect before rescaling the chart (default: 1).

=item --[no]tmux

Force C<tmux> colors mode.
By default, C<rainbarf> detects automatically if it is being called from C<tmux> or from the interactive shell.

=item --width

Chart width. Default is 38, so both the chart and the battery indicator fit the C<tmux> status line.
Higher values may require disabling the battery indicator or raising the C<status-right-length> value in F<~/.tmux.conf>.

=back

=head1 CAVEAT

=head2 Color scheme

If you only see the memory usage bars but no load chart, that's because your terminal's color scheme need an explicit distinction between foreground and background colors.
For instance, "red on red background" will be displayed as a red block on such terminals.
Thus, you may need the ANSI B<bright> attribute for greater contrast.
There are two problems with it, though:

=over 4

=item 1.

Other color schemes (notably, L<solarized|http://ethanschoonover.com/solarized>) have different meaning for the ANSI B<bright> attribute.
So using it will result in a quite psychedelic appearance.

=item 2.

The older versions of L<Term::ANSIColor> dependency do not recognize it at all, resulting in a confusing error message I<Invalid attribute name bright_yellow at ...>.
However, the whole L<Term::ANSIColor> is optional, it is only required to preview the effects of the L</OPTIONS> via command line before actually editing the F<~/.tmux.conf>.
That is, C<rainbarf --bright --tmux> B<is guaranteed to work> despite the outdated L<Term::ANSIColor>!

=back

=head2 Persistent storage

Load stats are persistently stored in the F<~/.rainbarf.dat> file.
Every C<rainbarf> execution will update and rotate that file.
Since C<tmux> calls C<rainbarf> periodically (every 15 seconds, by default), the chart will display load for the last ~9.5 minutes (15 * 38).
Thus, several C<tmux> instances running simultaneously for the same user will result in a faster chart scrolling.

=head1 REFERENCES

=over 4

=item *

L<uptime(1)|http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/uptime.1.html> is used to get the load stats if F</proc/loadavg> is unavailable.

=item *

L<vm_stat(1)|http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/vm_stat.1.html> is used to get the memory stats if F</proc/meminfo> is unavailable.

=item *

L<ioreg(8)|http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/ioreg.8.html> is used to get the battery status on I<Mac OS X>.

=item *

L<acpi(1)|http://manpages.ubuntu.com/manpages/precise/man1/acpi.1.html> is used to get the battery status on I<Linux>.

=item *

L<Battery|https://github.com/Goles/Battery> was a source of inspiration.

=item *

L<Spark|http://zachholman.com/spark/> was another source of inspiration.

=back

=head1 AUTHOR

Stanislaw Pusep <stas@sysd.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2013 by Stanislaw Pusep.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
